//Tabular data production - percent land cover by grid-cells in TNRD


/////////////////////////////////////////////////////////////////
//
// Define our region of interest
//
/////////////////////////////////////////////////////////////////

//BC shapefile with ADM 2
var BC = ee.FeatureCollection("FAO/GAUL/2015/level2")
.filter(ee.Filter.eq("ADM1_CODE", 826));

//Select all of Canada
var roi = ee.FeatureCollection("FAO/GAUL/2015/level0")
.filter(ee.Filter.eq("ADM0_NAME", "Canada"));

Map.addLayer(roi, {}, "All of Canada", 0);


/////////////////////////////////////////////////////////////////
//
// Create bounding box at 60th parallel
//
/////////////////////////////////////////////////////////////////

// Coordinates for the bounds of a rectangle. We can easily modify
var xMin = -144;
var yMin = 40;
var xMax = -50;
var yMax = 60;

// Construct a rectangle from a list of GeoJSON 'point' formatted coordinates.
var bbox = ee.Geometry.BBox(xMin, yMin, xMax, yMax);
var bbox = ee.Feature(bbox);
Map.addLayer(bbox, {}, "Box for cropping", 0);

/////////////////////////////////////////////////////////////////
//
// Crop Canada Feature Collection to bounding box
//
/////////////////////////////////////////////////////////////////

//Feature collection to geometry to feature
var roiGeo = roi.geometry();
var roiFeat = ee.Feature(roiGeo);

//Intersection of Canada and bbox
var studyArea = roiGeo.intersection(bbox);

Map.addLayer(studyArea);

//The resulting object is too large to map :,(

/////////////////////////////////////////////////////////////////
//
// Create 1 degree sample grids
//
/////////////////////////////////////////////////////////////////


var tiles = tile(studyArea, 1);

function tile(region, size_in_degrees) {
  function tile_geometry(geometry) {
    var coords = ee.List(geometry.bounds().coordinates().get(0))
    var min_point = ee.List(coords.get(0))
    var max_point = ee.List(coords.get(2))
  
    function sequence(direction) {
      var start = min_point.get(direction)  
      var stop = ee.Number(max_point.get(direction))
      return ee.List.sequence(start, stop, size_in_degrees)
    }
  
    var tiles = sequence(0).map(function (x) {
      return sequence(1).map(function (y) { 
          return ee.Feature(ee.Geometry.Rectangle([
            [ee.Number(x), ee.Number(y)],
            [
              ee.Number(x).add(size_in_degrees).min(max_point.get(0)),
              ee.Number(y).add(size_in_degrees).min(max_point.get(1))
            ]
        ]).intersection(geometry, 30))
      })
  	}).flatten()
    return ee.FeatureCollection(tiles).filterBounds(geometry)
  }

  function tile_feature_collection(feature_collection) {
    return ee.FeatureCollection(
      feature_collection.iterate(
        function (feature, acc) {
          return ee.FeatureCollection(acc).merge(tile_geometry(ee.Feature(feature).geometry()))
        }, ee.FeatureCollection([]))
    )
  }

  if (region instanceof ee.FeatureCollection)
    return tile_feature_collection(region)
  else if (region instanceof ee.Feature)
    return tile_geometry(region.geometry())
  else if (region instanceof ee.Geometry)
    return tile_geometry(region)
  else
    throw Error(
      'region must be ee.FeatureCollection, ee.Feature, or ee.Geometry. Was ' + region
    )
}

Map.centerObject(tiles, 7);
Map.addLayer(tiles, {}, "Sample tiles");

