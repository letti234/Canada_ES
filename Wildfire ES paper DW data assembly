/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var geometry = 
    /* color: #d63000 */
    /* shown: false */
    /* displayProperties: [
      {
        "type": "rectangle"
      }
    ] */
    ee.Geometry.Polygon(
        [[[-139.32109375000002, 60.056450293524826],
          [-139.32109375000002, 41.165999656105214],
          [-51.51835937500001, 41.165999656105214],
          [-51.51835937500001, 60.056450293524826]]], null, false);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
//Tabular data production - percent land cover by grid-cells in TNRD


/////////////////////////////////////////////////////////////////
//
// Define our region of interest using a bounding box
//
/////////////////////////////////////////////////////////////////


var bbox = ee.Geometry.BBox(-140, 41, -52, 60);
Map.addLayer(bbox, {color: "red"}, "Bounding box area", 0); print("Bounding box properties", bbox);

var bboxGeo = ee.Geometry(bbox);
// /////////////////////////////////////////////////////////////////
// //
// // Create 1 degree grid-cells
// //
// /////////////////////////////////////////////////////////////////


//Develop code using very coarse grid-cells

var tiles = tile(bboxGeo, 1); 

function tile(region, size_in_degrees) {
  function tile_geometry(geometry) {
    var coords = ee.List(geometry.bounds().coordinates().get(0))
    var min_point = ee.List(coords.get(0))
    var max_point = ee.List(coords.get(2))
  
    function sequence(direction) {
      var start = min_point.get(direction)  
      var stop = ee.Number(max_point.get(direction))
      return ee.List.sequence(start, stop, size_in_degrees)
    }
  
    var tiles = sequence(0).map(function (x) {
      return sequence(1).map(function (y) { 
          return ee.Feature(ee.Geometry.Rectangle([
            [ee.Number(x), ee.Number(y)],
            [
              ee.Number(x).add(size_in_degrees).min(max_point.get(0)),
              ee.Number(y).add(size_in_degrees).min(max_point.get(1))
            ]
        ]).intersection(geometry, 30))
      })
  	}).flatten()
    return ee.FeatureCollection(tiles).filterBounds(geometry)
  }

  function tile_feature_collection(feature_collection) {
    return ee.FeatureCollection(
      feature_collection.iterate(
        function (feature, acc) {
          return ee.FeatureCollection(acc).merge(tile_geometry(ee.Feature(feature).geometry()))
        }, ee.FeatureCollection([]))
    )
  }

  if (region instanceof ee.FeatureCollection)
    return tile_feature_collection(region)
  else if (region instanceof ee.Feature)
    return tile_geometry(region.geometry())
  else if (region instanceof ee.Geometry)
    return tile_geometry(region)
  else
    throw Error(
      'region must be ee.FeatureCollection, ee.Feature, or ee.Geometry. Was ' + region
    )
}

//Mapping of tiles

Map.addLayer(tiles, {color: "green"}, "Sample tiles", 0);
print(tiles.limit(2));


/////////////////////////////////////////////////////////////////
//
// Spatial intersection - subset to tiles that overlap Canada
//
/////////////////////////////////////////////////////////////////

//Simplified geometry object
var Canada= ee.FeatureCollection("FAO/GAUL/2015/level0")
.filter(ee.Filter.eq("ADM0_NAME", "Canada")).geometry().simplify(1000000);

// //Transform this object into a feature
// var CanadaFeat = ee.Feature(ee.Geometry(Canada));


// //Find centroids of each tile
// var getCentroid = function(feature) {
//   var keepProperties = ['id'];
//   var centroid = feature.geometry().centroid();
//   return ee.Feature(centroid).copyProperties(feature, keepProperties);
// };

// var centroids = tiles.map(getCentroid);
// print(centroids.limit(2));

// //Spatial filter for intersecting geometries

// var spatialFilter = ee.Filter.intersects({
//   leftField: '.geo',
//   rightField: '.geo'
// });

// var sample  = ee.Join.saveAll('matched').apply(centroids, CanadaFeat, spatialFilter);

// Map.addLayer(sample.limit(2));




// for more than one region (type: featureCollection), do something like:
var tilesGeom = tiles.map(function(f) {
  return f.geometry();
});

// Now map over your study sites and use intersect to clip them on the region(s)
var sampleTilesGeom = tilesGeom.map(function(f) {
  return f.intersection(Canada, 1); //1 refers to the maxError argument
});